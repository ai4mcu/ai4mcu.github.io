// translations.js - AI-EDU-KIT for MCU ë‹¤êµ­ì–´ ì§€ì›

// ê¸°ë³¸ ì–¸ì–´ ì‚¬ì „ (í•œêµ­ì–´, ì˜ì–´)
const translations = {
    // ë©”ì¸ í˜ì´ì§€
    main_title: {
        ko: "AI-EDU-KIT for MCU",
        en: "AI-EDU-KIT for MCU"
    },
    main_subtitle: {
        ko: "ì˜ìƒì²˜ë¦¬ ì¸ê³µì§€ëŠ¥ì„ í™œìš©í•´ í•˜ë“œì›¨ì–´ë¥¼ ì œì–´í•˜ëŠ” ë©‹ì§„ ê²½í—˜ì„ í•´ë³´ì„¸ìš”.",
        en: "Experience the amazing control of hardware using computer vision AI."
    },
    main_description: {
        ko: "ë§ˆì´í¬ë¡œë¹„íŠ¸, ì•„ë‘ì´ë…¸, ESP32, RP í”¼ì½”ë¥¼ ìœ ì„ ê³¼ ë¬´ì„ ìœ¼ë¡œ ì—°ê²°í•´ ì œì–´í•  ìˆ˜ ìˆì–´ìš”.",
        en: "Connect and control micro:bit, Arduino, ESP32, RP Pico via wired and wireless connections."
    },
    tm_title: {
        ko: "TM ì˜¬ì¸ì› ì„œë¹„ìŠ¤",
        en: "TM All-in-One Service"
    },
    tm_description: {
        ko: "Teachable Machineìœ¼ë¡œ í•™ìŠµí•œ ì´ë¯¸ì§€, í¬ì¦ˆ, ìŒì„± ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ MCUë¥¼ ì œì–´í•©ë‹ˆë‹¤.",
        en: "Control MCU using image, pose, and voice models trained with Teachable Machine."
    },
    face_title: {
        ko: "ì–¼êµ´ ì¸ì‹ ì˜¬ì¸ì› ì„œë¹„ìŠ¤",
        en: "Face Recognition All-in-One Service"
    },
    face_description: {
        ko: "MediaPipe ë¯¸ê°„ ì¢Œí‘œ, í•˜í’ˆ, ëˆˆ ê¹œë°•ì„, ì–¼êµ´ ê°œìˆ˜, í¬ê¸° ë“±ì„ ì‚¬ìš©í•˜ì—¬ MCUë¥¼ ì œì–´í•©ë‹ˆë‹¤.",
        en: "Control MCU using MediaPipe glabella coordinates, yawning, blinking, face count, size, etc."
    },
    hand_title: {
        ko: "ì†ê°€ë½ì¸ì‹ ì˜¬ì¸ì› ì„œë¹„ìŠ¤",
        en: "Hand Recognition All-in-One Service"
    },
    hand_description: {
        ko: "MediaPipeë¡œ ê²€ì§€ì¢Œí‘œ, ì—„ì§€-ê²€ì§€ ê¸¸ì´, ì†ê°€ë½ ì¹´ìš´íŒ…, ì–‘ì† ê²€ì§€ì¢Œí‘œ ë“±ì„ ì‚¬ìš©í•˜ì—¬ MCUë¥¼ ì œì–´í•©ë‹ˆë‹¤.",
        en: "Control MCU using MediaPipe index finger coordinates, thumb-index distance, finger counting, dual hand coordinates, etc."
    },
    voice_title: {
        ko: "ìŒì„±ì¸ì‹ ì„œë¹„ìŠ¤",
        en: "Voice Recognition Service"
    },
    voice_description: {
        ko: "Googleì˜ Web Speech APIë¡œ ìŒì„±ì¸ì‹ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ì—¬ MCUë¥¼ ì œì–´í•©ë‹ˆë‹¤.",
        en: "Control MCU using voice recognition results with Google's Web Speech API."
    },
    go_to_service: {
        ko: "ì„œë¹„ìŠ¤ ë°”ë¡œê°€ê¸°",
        en: "Go to Service"
    },
    coming_soon: {
        ko: "ê°œë°œì¤‘",
        en: "Coming Soon"
    },
    footer_copyright: {
        ko: "Â© 2025 AI-EDU-KIT. All Rights Reserved.",
        en: "Â© 2025 AI-EDU-KIT. All Rights Reserved."
    },
    footer_developed_by: {
        ko: "Developed by Seok-jeon Kim : alphaco@kakao.com",
        en: "Developed by Seok-jeon Kim : alphaco@kakao.com"
    },
    visitors_total: {
        ko: "ë°©ë¬¸ì: ",
        en: "Visitors: "
    },
    visitors_today: {
        ko: "ì˜¤ëŠ˜: ",
        en: "Today: "
    },
    visitors_unique: {
        ko: "ìˆœë°©ë¬¸ì: ",
        en: "Unique: "
    },

    // TM í˜ì´ì§€
    tm_page_title: {
        ko: "ğŸ¤– TM All-in-One for MCU",
        en: "ğŸ¤– TM All-in-One for MCU"
    },
    tm_page_subtitle: {
        ko: "Teachable Machine í†µí•© ì¸í„°í˜ì´ìŠ¤ - ì´ë¯¸ì§€, í¬ì¦ˆ, ìŒì„± ì¸ì‹",
        en: "Teachable Machine integrated interface - Image, Pose, Voice recognition"
    },
    tab_image: {
        ko: "ğŸ“· ì´ë¯¸ì§€ ì¸ì‹",
        en: "ğŸ“· Image Recognition"
    },
    tab_pose: {
        ko: "ğŸƒ í¬ì¦ˆ ì¸ì‹",
        en: "ğŸƒ Pose Recognition"
    },
    tab_voice: {
        ko: "ğŸ¤ ìŒì„± ì¸ì‹",
        en: "ğŸ¤ Voice Recognition"
    },
    image_model_settings: {
        ko: "ğŸ“· ì´ë¯¸ì§€ ëª¨ë¸ ì„¤ì •",
        en: "ğŸ“· Image Model Settings"
    },
    pose_model_settings: {
        ko: "ğŸƒ í¬ì¦ˆ ëª¨ë¸ ì„¤ì •",
        en: "ğŸƒ Pose Model Settings"
    },
    voice_model_settings: {
        ko: "ğŸ¤ ìŒì„± ëª¨ë¸ ì„¤ì •",
        en: "ğŸ¤ Voice Model Settings"
    },
    tm_model_url_image: {
        ko: "Teachable Machine ì´ë¯¸ì§€ ëª¨ë¸ URL",
        en: "Teachable Machine Image Model URL"
    },
    tm_model_url_pose: {
        ko: "Teachable Machine í¬ì¦ˆ ëª¨ë¸ URL",
        en: "Teachable Machine Pose Model URL"
    },
    tm_model_url_voice: {
        ko: "Teachable Machine ìŒì„± ëª¨ë¸ URL",
        en: "Teachable Machine Voice Model URL"
    },
    threshold: {
        ko: "ì¸ì‹ ì„ê³„ê°’ (0-100)",
        en: "Recognition Threshold (0-100)"
    },
    load_model: {
        ko: "ëª¨ë¸ ë¡œë“œ",
        en: "Load Model"
    },
    start: {
        ko: "ì‹œì‘",
        en: "Start"
    },
    stop: {
        ko: "ì •ì§€",
        en: "Stop"
    },
    start_voice: {
        ko: "ìŒì„± ì¸ì‹ ì‹œì‘",
        en: "Start Voice Recognition"
    },
    webcam_select: {
        ko: "ì›¹ìº  ì„ íƒ",
        en: "Select Webcam"
    },

    // í•¸ë“œ í˜ì´ì§€
    hand_page_title: {
        ko: "âœ‹ ì†ê°€ë½ ì¸ì‹ ì˜¬ì¸ì›",
        en: "âœ‹ Hand Recognition All-in-One"
    },
    hand_page_subtitle: {
        ko: "MediaPipeì˜ ì† ì¸ì‹ ê¸°ìˆ ì„ í™œìš©í•œ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.",
        en: "Various functions using MediaPipe hand recognition technology."
    },
    tab_hand_coords: {
        ko: "ğŸ‘† ê²€ì§€ì¢Œí‘œ",
        en: "ğŸ‘† Index Coords"
    },
    tab_thumb_dist: {
        ko: "ğŸ“ ì—„ì§€-ê²€ì§€ ê¸¸ì´",
        en: "ğŸ“ Thumb-Index Distance"
    },
    tab_finger_count: {
        ko: "ğŸ–ï¸ ì†ê°€ë½ ì¹´ìš´íŒ…",
        en: "ğŸ–ï¸ Finger Counting"
    },
    tab_dual_coords: {
        ko: "âœŒï¸ ì–‘ì† ê²€ì§€ì¢Œí‘œ",
        en: "âœŒï¸ Dual Hand Coords"
    },
    tab_hand_service5: {
        ko: "âœ¨ ì„œë¹„ìŠ¤ 5",
        en: "âœ¨ Service 5"
    },
    tab_hand_service6: {
        ko: "âœ¨ ì„œë¹„ìŠ¤ 6",
        en: "âœ¨ Service 6"
    },
    index_finger_coords: {
        ko: "ê²€ì§€ ë ì¢Œí‘œ",
        en: "Index Finger Tip Coordinates"
    },
    thumb_index_dist: {
        ko: "ì—„ì§€-ê²€ì§€ ì‚¬ì´ ê±°ë¦¬",
        en: "Thumb-Index Distance"
    },
    total_finger_count: {
        ko: "ì´ ì†ê°€ë½ ê°œìˆ˜",
        en: "Total Finger Count"
    },
    left_hand: {
        ko: "ì™¼ì†",
        en: "Left Hand"
    },
    right_hand: {
        ko: "ì˜¤ë¥¸ì†",
        en: "Right Hand"
    },
    dual_hand_coords: {
        ko: "ì–‘ì† ê²€ì§€ ì¢Œí‘œ",
        en: "Dual Hand Index Coordinates"
    },

    // ì–¼êµ´ í˜ì´ì§€
    face_page_title: {
        ko: "ğŸ˜€ ì–¼êµ´ ì¸ì‹ ì˜¬ì¸ì›",
        en: "ğŸ˜€ Face Recognition All-in-One"
    },
    face_page_subtitle: {
        ko: "MediaPipeì˜ ì–¼êµ´ ì¸ì‹ ê¸°ìˆ ì„ í™œìš©í•œ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.",
        en: "Various functions using MediaPipe face recognition technology."
    },
    tab_face_coords: {
        ko: "ğŸ“ ë¯¸ê°„ ì¢Œí‘œ",
        en: "ğŸ“ Glabella Coords"
    },
    tab_yawn: {
        ko: "ğŸ‘„ í•˜í’ˆ ê°ì§€",
        en: "ğŸ‘„ Yawn Detection"
    },
    tab_blink: {
        ko: "ğŸ‘ï¸ ëˆˆ ê¹œë°•ì„",
        en: "ğŸ‘ï¸ Blink Detection"
    },
    tab_face_count: {
        ko: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ì–¼êµ´ ê°œìˆ˜",
        en: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Face Count"
    },
    tab_face_size: {
        ko: "ğŸ“ ì–¼êµ´ í¬ê¸°",
        en: "ğŸ“ Face Size"
    },
    tab_face_service6: {
        ko: "âœ¨ ì„œë¹„ìŠ¤ 6",
        en: "âœ¨ Service 6"
    },
    glabella_coords: {
        ko: "ë¯¸ê°„ ì¤‘ì‹¬ ì¢Œí‘œ",
        en: "Glabella Center Coordinates"
    },
    mouth_open_size: {
        ko: "ì… ë²Œë¦¼ í¬ê¸°",
        en: "Mouth Opening Size"
    },
    blink_status: {
        ko: "ëˆˆ ê¹œë°•ì„ ìƒíƒœ (1: ê¹œë°•ì„, 0: í‰ìƒì‹œ)",
        en: "Blink Status (1: Blinking, 0: Normal)"
    },
    left_eye: {
        ko: "ì™¼ìª½:",
        en: "Left:"
    },
    right_eye: {
        ko: "ì˜¤ë¥¸ìª½:",
        en: "Right:"
    },
    both_eyes: {
        ko: "ì–‘ìª½:",
        en: "Both:"
    },
    detected_face_count: {
        ko: "ê°ì§€ëœ ì–¼êµ´ ê°œìˆ˜",
        en: "Detected Face Count"
    },
    unit_faces: {
        ko: "ê°œ",
        en: "faces"
    },
    face_box_size: {
        ko: "ì–¼êµ´ ìƒì í¬ê¸° (ë„ˆë¹„, ë†’ì´)",
        en: "Face Box Size (Width, Height)"
    },

    // ìŒì„± í˜ì´ì§€
    voice_page_title: {
        ko: "ğŸ¤ ìŒì„±ì¸ì‹ ì„œë¹„ìŠ¤",
        en: "ğŸ¤ Voice Recognition Service"
    },
    voice_page_subtitle: {
        ko: "Google Web Speech APIë¥¼ ì‚¬ìš©í•˜ì—¬ ìŒì„±ìœ¼ë¡œ MCUë¥¼ ì œì–´í•©ë‹ˆë‹¤.",
        en: "Control MCU with voice using Google Web Speech API."
    },
    voice_recognition_control: {
        ko: "ìŒì„±ì¸ì‹ ì œì–´",
        en: "Voice Recognition Control"
    },
    language_select: {
        ko: "ì–¸ì–´ ì„ íƒ",
        en: "Language Selection"
    },
    start_recognition: {
        ko: "ì¸ì‹ ì‹œì‘",
        en: "Start Recognition"
    },
    stop_recognition: {
        ko: "ì¸ì‹ ì •ì§€",
        en: "Stop Recognition"
    },
    recognition_waiting: {
        ko: "ì¸ì‹ ëŒ€ê¸°ì¤‘",
        en: "Recognition Waiting"
    },
    voice_recognizing: {
        ko: "ìŒì„± ì¸ì‹ ì¤‘...",
        en: "Voice Recognizing..."
    },
    recognition_error: {
        ko: "ì¸ì‹ ì˜¤ë¥˜",
        en: "Recognition Error"
    },
    final_recognized_sentence: {
        ko: "ìµœì¢… ì¸ì‹ëœ ë¬¸ì¥:",
        en: "Final Recognized Sentence:"
    },
    command_transmission_settings: {
        ko: "ëª…ë ¹ì–´/ì „ì†¡ ê°’ ì„¤ì • (ìµœëŒ€ 20ê°œ)",
        en: "Command/Transmission Value Settings (Max 20)"
    },
    word_to_recognize_placeholder: {
        ko: "ì¸ì‹í•  ë‹¨ì–´ (ì˜ˆ: ë¶ˆ ì¼œ)",
        en: "Word to recognize (e.g., turn on)"
    },
    transmission_value_placeholder: {
        ko: "ì „ì†¡ ê°’ (ì˜ˆ: 1)",
        en: "Transmission value (e.g., 1)"
    },
    max_commands_limit: {
        ko: "ëª…ë ¹ì–´ëŠ” ìµœëŒ€ 20ê°œê¹Œì§€ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        en: "You can add up to 20 commands maximum."
    },
    browser_not_supported: {
        ko: "ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.",
        en: "This browser does not support voice recognition. Please use Chrome browser."
    },
    guide_voice_1: {
        ko: "ì‚¬ìš©í•  ì–¸ì–´ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.",
        en: "Select the language to use."
    },
    guide_voice_2: {
        ko: "'+' ë²„íŠ¼ì„ ëˆŒëŸ¬ ì¸ì‹í•  ë‹¨ì–´ì™€ MCUë¡œ ë³´ë‚¼ ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤. (ìµœëŒ€ 20ê°œ)",
        en: "Press the '+' button to set words to recognize and values to send to MCU. (Max 20)"
    },
    guide_voice_3: {
        ko: "ì‹œë¦¬ì–¼ ë˜ëŠ” ë¸”ë£¨íˆ¬ìŠ¤ë¡œ ì œì–´í•  ì¥ì¹˜ë¥¼ ì—°ê²°í•©ë‹ˆë‹¤.",
        en: "Connect the device to control via Serial or Bluetooth."
    },
    guide_voice_4: {
        ko: "'ì¸ì‹ ì‹œì‘' ë²„íŠ¼ì„ ëˆ„ë¥´ê³  ì„¤ì •í•œ ë‹¨ì–´ë¥¼ í¬í•¨í•˜ì—¬ ë§í•©ë‹ˆë‹¤.",
        en: "Press 'Start Recognition' button and speak including the set words."
    },
    guide_voice_5: {
        ko: "ë‹¨ì–´ê°€ ì¸ì‹ë˜ë©´ í•´ë‹¹ ì¹¸ì´ ë¶‰ê²Œ ê°•ì¡°ë˜ë©° ì„¤ì •ëœ ê°’ì´ ìë™ìœ¼ë¡œ ì „ì†¡ë©ë‹ˆë‹¤.",
        en: "When a word is recognized, the corresponding field is highlighted in red and the set value is automatically transmitted."
    },
    back_to_main: {
        ko: "ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°",
        en: "Back to Main"
    },

    // ê³µí†µ ìš”ì†Œ
    connection_settings: {
        ko: "ğŸ”Œ ì—°ê²° ì„¤ì •",
        en: "ğŸ”Œ Connection Settings"
    },
    ble_device_type: {
        ko: "ë¸”ë£¨íˆ¬ìŠ¤ ì¥ì¹˜ ìœ í˜•",
        en: "Bluetooth Device Type"
    },
    microbit_device: {
        ko: "ë§ˆì´í¬ë¡œë¹„íŠ¸ (ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰)",
        en: "micro:bit (Search by name)"
    },
    generic_uart_device: {
        ko: "ì¼ë°˜ UART ì¥ì¹˜ (Arduino, ESP32 ë“±)",
        en: "Generic UART Device (Arduino, ESP32, etc.)"
    },
    serial_connect: {
        ko: "ì‹œë¦¬ì–¼ ì—°ê²°",
        en: "Serial Connect"
    },
    serial_disconnect: {
        ko: "í•´ì œ",
        en: "Disconnect"
    },
    ble_connect: {
        ko: "ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²°",
        en: "Bluetooth Connect"
    },
    ble_disconnect: {
        ko: "í•´ì œ",
        en: "Disconnect"
    },
    status_connected: {
        ko: "{connectionType} ì—°ê²°ë¨",
        en: "{connectionType} Connected"
    },
    status_disconnected: {
        ko: "ì—°ê²° ì•ˆë¨",
        en: "Not Connected"
    },
    start_recognition: {
        ko: "ì¸ì‹ ì‹œì‘",
        en: "Start Recognition"
    },
    loading_model: {
        ko: "ëª¨ë¸ ë¡œë”©ì¤‘...",
        en: "Loading Model..."
    },
    recognizing: {
        ko: "ì¸ì‹ì¤‘...",
        en: "Recognizing..."
    },
    status_waiting: {
        ko: "ëŒ€ê¸° ì¤‘...",
        en: "Waiting..."
    },

    // ì‚¬ìš© ê°€ì´ë“œ
    usage_guide: {
        ko: "ğŸ’¡ ì‚¬ìš© ë°©ë²•",
        en: "ğŸ’¡ Usage Guide"
    },
    guide_tm_1: {
        ko: "ì‚¬ìš©í•  ì¸ì‹ ëª¨ë“œ(ì´ë¯¸ì§€/í¬ì¦ˆ/ìŒì„±)ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
        en: "Select the recognition mode (Image/Pose/Voice) to use."
    },
    guide_tm_2: {
        ko: "Teachable Machineì—ì„œ í•™ìŠµí•œ ëª¨ë¸ URLì„ ì…ë ¥í•˜ì„¸ìš”.",
        en: "Enter the trained model URL from Teachable Machine."
    },
    guide_tm_3: {
        ko: "ì—°ê²°í•  ì¥ì¹˜(ì‹œë¦¬ì–¼ ë˜ëŠ” ë¸”ë£¨íˆ¬ìŠ¤)ë¥¼ ì„ íƒí•˜ê³  ì—°ê²°í•˜ì„¸ìš”.",
        en: "Select and connect the device (Serial or Bluetooth)."
    },
    guide_tm_4: {
        ko: "ëª¨ë¸ì„ ë¡œë“œí•˜ê³  ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
        en: "Load the model and press the start button."
    },
    guide_tm_5: {
        ko: "ì¸ì‹ëœ ê²°ê³¼ê°€ ìë™ìœ¼ë¡œ MCUë¡œ ì „ì†¡ë©ë‹ˆë‹¤.",
        en: "Recognition results are automatically sent to MCU."
    },
    guide_hand_1: {
        ko: "ìƒë‹¨ íƒ­ì—ì„œ ì›í•˜ëŠ” ì† ì¸ì‹ ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš”.",
        en: "Select the desired hand recognition function from the top tabs."
    },
    guide_hand_2: {
        ko: "'ì¸ì‹ ì‹œì‘' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¹´ë©”ë¼ë¥¼ í™œì„±í™”í•˜ì„¸ìš”.",
        en: "Click 'Start Recognition' button to activate the camera."
    },
    guide_hand_3: {
        ko: "MCU ì¥ì¹˜ë¥¼ ì‹œë¦¬ì–¼ ë˜ëŠ” ë¸”ë£¨íˆ¬ìŠ¤ë¡œ ì—°ê²°í•˜ì„¸ìš”.",
        en: "Connect MCU device via Serial or Bluetooth."
    },
    guide_hand_4: {
        ko: "ì†ì´ ì¸ì‹ë˜ë©´ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°ì´í„°ê°€ MCUë¡œ ì „ì†¡ë©ë‹ˆë‹¤.",
        en: "When hands are detected, data is transmitted to MCU in real-time."
    },
    guide_hand_5: {
        ko: "MCUì—ì„œ ìˆ˜ì‹ í•œ ë°ì´í„°ë¥¼ í™œìš©í•˜ì—¬ ë‹¤ì–‘í•œ ì¶œë ¥ì¥ì¹˜ë¥¼ ì œì–´í•˜ì„¸ìš”.",
        en: "Use the received data on MCU to control various output devices."
    },
    guide_face_1: {
        ko: "ìƒë‹¨ íƒ­ì—ì„œ ì›í•˜ëŠ” ì–¼êµ´ ì¸ì‹ ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš”.",
        en: "Select the desired face recognition function from the top tabs."
    },
    guide_face_2: {
        ko: "'ì¸ì‹ ì‹œì‘' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¹´ë©”ë¼ë¥¼ í™œì„±í™”í•˜ì„¸ìš”.",
        en: "Click 'Start Recognition' button to activate the camera."
    },
    guide_face_3: {
        ko: "MCU ì¥ì¹˜ë¥¼ ì‹œë¦¬ì–¼ ë˜ëŠ” ë¸”ë£¨íˆ¬ìŠ¤ë¡œ ì—°ê²°í•˜ì„¸ìš”.",
        en: "Connect MCU device via Serial or Bluetooth."
    },
    guide_face_4: {
        ko: "ì–¼êµ´ì´ ì¸ì‹ë˜ë©´ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°ì´í„°ê°€ MCUë¡œ ì „ì†¡ë©ë‹ˆë‹¤.",
        en: "When faces are detected, data is transmitted to MCU in real-time."
    },
    guide_face_5: {
        ko: "MCUì—ì„œ ìˆ˜ì‹ í•œ ë°ì´í„°ë¥¼ í™œìš©í•˜ì—¬ ë‹¤ì–‘í•œ ì¶œë ¥ì¥ì¹˜ë¥¼ ì œì–´í•˜ì„¸ìš”.",
        en: "Use the received data on MCU to control various output devices."
    },

    // ê°œë°œì ì •ë³´
    developer_info: {
        ko: "ğŸ‘¨â€ğŸ’» ê°œë°œì ì •ë³´",
        en: "ğŸ‘¨â€ğŸ’» Developer Information"
    },
    developer_name: {
        ko: "ê¹€ì„ì „, ì†¡ë„ì¤‘í•™êµ ì •ë³´êµì‚¬ / ì¸í•˜ëŒ€í•™êµ ê²¸ì„êµìˆ˜ ğŸ“… Since 2023.04.24 | ğŸ“§ alphaco@kakao.com",
        en: "Kim Seok-jeon, Information Teacher at Songdo Middle School / Adjunct Professor at Inha University ğŸ“… Since 2023.04.24 | ğŸ“§ alphaco@kakao.com"
    },
    developer_info_tm: {
        ko: "WebSerialê³¼ WebBLEë¥¼ ì´ìš©í•´ TM ê²°ê³¼ë¥¼ ìœ /ë¬´ì„  MCUë¡œ ì „ì†¡í•˜ëŠ” ì›¹ì•±ì…ë‹ˆë‹¤.",
        en: "Web app that transmits TM results to wired/wireless MCU using WebSerial and WebBLE."
    },
    developer_info_hand: {
        ko: "WebSerialê³¼ WebBLEë¥¼ ì´ìš©í•´ ì†ê°€ë½ ì¸ì‹ ê²°ê³¼ë¥¼ ìœ /ë¬´ì„ ìœ¼ë¡œ MCUì— ì „ì†¡í•˜ëŠ” ì›¹ì•±ì…ë‹ˆë‹¤.",
        en: "Web app that transmits hand recognition results to MCU via wired/wireless using WebSerial and WebBLE."
    },
    developer_info_face: {
        ko: "WebSerialê³¼ WebBLEë¥¼ ì´ìš©í•´ ì–¼êµ´ ì¸ì‹ ê²°ê³¼ë¥¼ ìœ /ë¬´ì„ ìœ¼ë¡œ MCUì— ì „ì†¡í•˜ëŠ” ì›¹ì•±ì…ë‹ˆë‹¤.",
        en: "Web app that transmits face recognition results to MCU via wired/wireless using WebSerial and WebBLE."
    },
    developer_info_voice: {
        ko: "WebSerialê³¼ WebBLEë¥¼ ì´ìš©í•´ ìŒì„± ì¸ì‹ ê²°ê³¼ë¥¼ ìœ /ë¬´ì„  MCUë¡œ ì „ì†¡í•˜ëŠ” ì›¹ì•±ì…ë‹ˆë‹¤.",
        en: "Web app that transmits voice recognition results to wired/wireless MCU using WebSerial and WebBLE."
    },
    app_description_2: {
        ko: "âœ… ì•„ë‘ì´ë…¸, ë§ˆì´í¬ë¡œë¹„íŠ¸, ESP32, ë¼ì¦ˆë² ë¦¬íŒŒì´ í”¼ì½” ë“± ëª¨ë“  MCUë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        en: "âœ… Compatible with all MCUs including Arduino, micro:bit, ESP32, Raspberry Pi Pico, etc."
    },
    app_description_3: {
        ko: "ğŸŒ Chrome, Edge ë¸Œë¼ìš°ì €ì—ì„œ í…ŒìŠ¤íŠ¸ ë˜ì—ˆìŠµë‹ˆë‹¤.",
        en: "ğŸŒ Tested on Chrome and Edge browsers."
    },
    app_description_5: {
        ko: "ğŸš€ ì¸ê³µì§€ëŠ¥ì— ë‹¤ì–‘í•œ ì¶œë ¥ì¥ì¹˜ë¥¼ ì—°ê²°í•˜ì—¬ AIoT ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì œì‘í•´ ë³´ì„¸ìš”.",
        en: "ğŸš€ Create AIoT applications by connecting various output devices to AI."
    },
    ccl: {
        ko: "ğŸ“œ CCL: BY-NC-ND",
        en: "ğŸ“œ CCL: BY-NC-ND"
    },

    // ì—ëŸ¬ ë©”ì‹œì§€ ë° ì•Œë¦¼
    enter_model_url: {
        ko: "{modelType} ëª¨ë¸ URLì„ ì…ë ¥í•˜ì„¸ìš”!",
        en: "Please enter {modelType} model URL!"
    },
    model_loaded: {
        ko: "{modelType} ëª¨ë¸ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!",
        en: "{modelType} model loaded successfully!"
    },
    model_load_failed: {
        ko: "ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: {error}",
        en: "Model load failed: {error}"
    },
    recognition_result: {
        ko: "ì¸ì‹ ê²°ê³¼: {result}",
        en: "Recognition Result: {result}"
    },
    serial_connect_error: {
        ko: "ì‹œë¦¬ì–¼ ì—°ê²° ì‹¤íŒ¨: {error}",
        en: "Serial connection failed: {error}"
    },
    ble_connect_success: {
        ko: "ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ì„±ê³µ!",
        en: "Bluetooth connected successfully!"
    },
    ble_connect_error: {
        ko: "ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ì‹¤íŒ¨: {error}",
        en: "Bluetooth connection failed: {error}"
    },
    voice_recognition_started: {
        ko: "ìŒì„± ì¸ì‹ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!",
        en: "Voice recognition started!"
    },
    no_webcam: {
        ko: "ì›¹ìº ì´ ì—†ìŠµë‹ˆë‹¤",
        en: "No webcam available"
    },
    webcam_permission: {
        ko: "ì›¹ìº  ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
        en: "Webcam permission required"
    },
    webcam_changed: {
        ko: "ì›¹ìº ì´ {webcamName}ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.",
        en: "Webcam changed to {webcamName}."
    },
    context_menu_blocked: {
        ko: "ìš°í´ë¦­ì€ ê¸ˆì§€ë˜ì–´ ìˆìŠµë‹ˆë‹¤.",
        en: "Right-click is disabled."
    },

    // ê´€ë¦¬ì ê¸°ëŠ¥
    admin_log_button: {
        ko: "ğŸ”’ ê´€ë¦¬ì ë¡œê·¸",
        en: "ğŸ”’ Admin Log"
    },
    download_csv_button: {
        ko: "ğŸ“„ CSV ë‹¤ìš´ë¡œë“œ",
        en: "ğŸ“„ Download CSV"
    },
    admin_log_title: {
        ko: "ê´€ë¦¬ì ë°©ë¬¸ì ë¡œê·¸",
        en: "Admin Visitor Log"
    }
};

// í˜„ì¬ ì–¸ì–´ ê°ì§€
let currentLanguage = 'ko';

// ì–¸ì–´ ê°ì§€ í•¨ìˆ˜
function detectLanguage() {
    // ë¸Œë¼ìš°ì € ì–¸ì–´ ê°ì§€
    const browserLang = navigator.language || navigator.languages[0] || 'ko';
    
    // ì§€ì›í•˜ëŠ” ì–¸ì–´ ëª©ë¡ (ê¸°ë³¸ ì‚¬ì „ì— ìˆëŠ” ì–¸ì–´ë“¤)
    const supportedLanguages = ['ko', 'en'];
    
    // ë¸Œë¼ìš°ì € ì–¸ì–´ê°€ ì§€ì›ë˜ëŠ”ì§€ í™•ì¸
    const detectedLang = browserLang.substring(0, 2);
    
    if (supportedLanguages.includes(detectedLang)) {
        return detectedLang;
    }
    
    // ì§€ì›ë˜ì§€ ì•ŠëŠ” ì–¸ì–´ë©´ ì˜ì–´ë¡œ ê¸°ë³¸ ì„¤ì •
    return 'en';
}

// ìë™ ë²ˆì—­ API í•¨ìˆ˜ (Google Translate ë˜ëŠ” ê¸°íƒ€ ì„œë¹„ìŠ¤ ì‚¬ìš©)
async function translateText(text, targetLang) {
    try {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Google Translate API ë“±ì„ ì‚¬ìš©
        // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ì˜ˆì‹œë¡œ êµ¬í˜„
        
        // ê¸°ë³¸ ì‚¬ì „ì— ìˆëŠ” ê²½ìš° ë°”ë¡œ ë°˜í™˜
        if (translations[text] && translations[text][targetLang]) {
            return translations[text][targetLang];
        }
        
        // ìë™ ë²ˆì—­ì´ í•„ìš”í•œ ê²½ìš° (ì‹¤ì œë¡œëŠ” API í˜¸ì¶œ)
        // í˜„ì¬ëŠ” ê¸°ë³¸ê°’ ë°˜í™˜
        return text;
        
    } catch (error) {
        console.error('Translation error:', error);
        return text;
    }
}

// ë²ˆì—­ í•¨ìˆ˜
function _t(key, params = {}) {
    try {
        // ê¸°ë³¸ ì‚¬ì „ì—ì„œ ì°¾ê¸°
        if (translations[key] && translations[key][currentLanguage]) {
            let text = translations[key][currentLanguage];
            
            // ë§¤ê°œë³€ìˆ˜ ì¹˜í™˜
            Object.keys(params).forEach(param => {
                text = text.replace(new RegExp(`{${param}}`, 'g'), params[param]);
            });
            
            return text;
        }
        
        // í•œêµ­ì–´ ê¸°ë³¸ê°’ì´ ìˆëŠ” ê²½ìš°
        if (translations[key] && translations[key]['ko']) {
            return translations[key]['ko'];
        }
        
        // í‚¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° í‚¤ ìì²´ ë°˜í™˜
        return key;
        
    } catch (error) {
        console.error('Translation function error:', error);
        return key;
    }
}

// í˜ì´ì§€ì˜ ëª¨ë“  ë²ˆì—­ ê°€ëŠ¥í•œ ìš”ì†Œ ì—…ë°ì´íŠ¸
function updatePageTranslations() {
    const elementsWithTranslateKey = document.querySelectorAll('[data-translate-key]');
    
    elementsWithTranslateKey.forEach(element => {
        const key = element.getAttribute('data-translate-key');
        const translatedText = _t(key);
        
        // ì…ë ¥ ìš”ì†Œì˜ placeholder ì²˜ë¦¬
        if (element.tagName.toLowerCase() === 'input' && element.hasAttribute('placeholder')) {
            element.placeholder = translatedText;
        } else {
            element.textContent = translatedText;
        }
    });
}

// ì–¸ì–´ ì„¤ì • í•¨ìˆ˜
function setLanguage(lang = null) {
    if (lang) {
        currentLanguage = lang;
    } else {
        currentLanguage = detectLanguage();
    }
    
    // localStorageì— ì–¸ì–´ ì„¤ì • ì €ì¥
    try {
        localStorage.setItem('ai-edu-kit-language', currentLanguage);
    } catch (e) {
        console.warn('Cannot save language preference:', e);
    }
    
    updatePageTranslations();
}

// ì €ì¥ëœ ì–¸ì–´ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
function loadSavedLanguage() {
    try {
        const savedLang = localStorage.getItem('ai-edu-kit-language');
        if (savedLang && ['ko', 'en'].includes(savedLang)) {
            currentLanguage = savedLang;
            return;
        }
    } catch (e) {
        console.warn('Cannot load language preference:', e);
    }
    
    // ì €ì¥ëœ ì„¤ì •ì´ ì—†ìœ¼ë©´ ìë™ ê°ì§€
    currentLanguage = detectLanguage();
}

// ì–¸ì–´ ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (í•„ìš”ì‹œ ì‚¬ìš©)
function addLanguageSelector() {
    // í˜ì´ì§€ì— ì–¸ì–´ ì„ íƒê¸°ë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©
    const languageSelector = document.createElement('select');
    languageSelector.id = 'language-selector';
    languageSelector.innerHTML = `
        <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
        <option value="en">ğŸ‡ºğŸ‡¸ English</option>
    `;
    
    languageSelector.value = currentLanguage;
    languageSelector.addEventListener('change', (e) => {
        setLanguage(e.target.value);
    });
    
    return languageSelector;
}

// ì´ˆê¸°í™” í•¨ìˆ˜
function initializeTranslations() {
    loadSavedLanguage();
    updatePageTranslations();
    
    // DOMì´ ë³€ê²½ë  ë•Œë§ˆë‹¤ ë²ˆì—­ ì—…ë°ì´íŠ¸ (ì˜µì…˜)
    if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const elementsWithTranslateKey = node.querySelectorAll ? 
                            node.querySelectorAll('[data-translate-key]') : [];
                        elementsWithTranslateKey.forEach(element => {
                            const key = element.getAttribute('data-translate-key');
                            const translatedText = _t(key);
                            if (element.tagName.toLowerCase() === 'input' && element.hasAttribute('placeholder')) {
                                element.placeholder = translatedText;
                            } else {
                                element.textContent = translatedText;
                            }
                        });
                    }
                });
            });
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì´ˆê¸°í™”
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeTranslations);
} else {
    initializeTranslations();
}

// ì „ì—­ í•¨ìˆ˜ë¡œ ë…¸ì¶œ
window.setLanguage = setLanguage;
window._t = _t;
window.addLanguageSelector = addLanguageSelector;